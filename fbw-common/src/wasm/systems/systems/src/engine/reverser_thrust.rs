use uom::si::{
    acceleration::meter_per_second_squared,
    angular_acceleration::radian_per_second_squared,
    f64::*,
    force::newton,
    length::meter,
    mass::{kilogram, pound},
    ratio::{percent, ratio},
    torque::kilogram_force_meter,
    velocity::{foot_per_second, meter_per_second},
};

use crate::{
    shared::{
        interpolation, EngineCorrectedN1, EngineCorrectedN2, EngineUncorrectedN2, ReverserPosition,
    },
    simulation::{Read, SimulationElement, SimulatorReader, SimulatorWriter, UpdateContext, Write},
};

use crate::simulation::{InitContext, VariableIdentifier};

#[derive(Copy, Clone)]
struct ReverserThrust {
    current_thrust: Force,
}
impl ReverserThrust {
    const MIN_REVERSER_POS: f64 = 0.2;

    fn new() -> Self {
        Self {
            current_thrust: Force::default(),
        }
    }
    fn update(
        &mut self,
        engine_n1: &impl EngineCorrectedN1,
        reverser_position: &impl ReverserPosition,
        current_net_thrust: Mass,
    ) {
        self.current_thrust = if reverser_position.reverser_position().get::<ratio>()
            > Self::MIN_REVERSER_POS
        {
            let current_thrust_force =
                Force::new::<newton>(current_net_thrust.get::<kilogram>() * 9.80665);

            let final_debug = (current_thrust_force
                + current_thrust_force * Self::reverse_thrust_ratio_from_n1(engine_n1))
                * reverser_position.reverser_position();
            println!(
                    "!!!!!!!!!!!!!!!!!NEW CALC NET THRUST: {:.0} Force {:.0} Reverse Force {:.0} FinalInjected {:.0}",
                    current_net_thrust.get::<pound>(),
                    current_thrust_force.get::<newton>(),
                    current_thrust_force.get::<newton>()
                        * Self::reverse_thrust_ratio_from_n1(engine_n1).get::<ratio>(),
                        final_debug.get::<newton>()
                );

            // Total net thrust with reverser will need to cancel out forward thrust generated by engine + added desired reverse thrust
            (current_thrust_force
                + current_thrust_force * Self::reverse_thrust_ratio_from_n1(engine_n1))
                * reverser_position.reverser_position()
        } else {
            Force::default()
        };
    }

    fn current_thrust(&self) -> Force {
        self.current_thrust
    }

    fn forward_thrust_from_n1(engine_n1: &impl EngineCorrectedN1) -> Force {
        let n1_breakpoints = [0., 15., 20., 50., 55.];
        let forward_thrust = [0., 0., 7000., 30000., 51000.];

        Force::new::<newton>(interpolation(
            &n1_breakpoints,
            &forward_thrust,
            engine_n1.corrected_n1().get::<percent>(),
        ))
    }

    fn reverse_thrust_ratio_from_n1(engine_n1: &impl EngineCorrectedN1) -> Ratio {
        let n1_breakpoints = [0., 15., 20., 50., 55.];

        let reverse_thrust_ratio = [0., 0., 0., 0.4, 0.42];

        Ratio::new::<ratio>(interpolation(
            &n1_breakpoints,
            &reverse_thrust_ratio,
            engine_n1.corrected_n1().get::<percent>(),
        ))
    }
}

pub struct ReverserForce {
    reverser_delta_speed_id: VariableIdentifier,
    reverser_angular_accel_id: VariableIdentifier,
    engine_1_thrust_id: VariableIdentifier,
    engine_2_thrust_id: VariableIdentifier,

    reversers: [ReverserThrust; 2],

    plane_delta_speed_due_to_reverse_thrust: Velocity,

    dissimetry_acceleration: AngularAcceleration,

    engines_thrust: [Mass; 2],
}
impl ReverserForce {
    const DISTANCE_FROM_CG_TO_ENGINE_METER: f64 = 8.;

    pub fn new(context: &mut InitContext) -> Self {
        Self {
            reverser_delta_speed_id: context.get_identifier("REVERSER_DELTA_SPEED".to_owned()),
            reverser_angular_accel_id: context
                .get_identifier("REVERSER_ANGULAR_ACCELERATION".to_owned()),
            engine_1_thrust_id: context.get_identifier("TURB ENG JET THRUST:1".to_owned()),
            engine_2_thrust_id: context.get_identifier("TURB ENG JET THRUST:2".to_owned()),

            reversers: [ReverserThrust::new(); 2],
            plane_delta_speed_due_to_reverse_thrust: Velocity::default(),
            dissimetry_acceleration: AngularAcceleration::default(),

            engines_thrust: [Mass::default(); 2],
        }
    }

    pub fn update(
        &mut self,
        context: &UpdateContext,
        engine_n1: [&impl EngineCorrectedN1; 2],
        reverser_position: &[impl ReverserPosition],
    ) {
        for (engine_index, reverser) in self.reversers.iter_mut().enumerate() {
            reverser.update(
                engine_n1[engine_index],
                &reverser_position[engine_index],
                self.engines_thrust[engine_index],
            );
        }

        let total_force = self.reversers[0].current_thrust() + self.reversers[1].current_thrust();

        let acceleration = if context.total_weight().get::<kilogram>() > 0. {
            -total_force / context.total_weight()
        } else {
            Acceleration::default()
        };

        self.plane_delta_speed_due_to_reverse_thrust = Velocity::new::<meter_per_second>(
            acceleration.get::<meter_per_second_squared>() * context.delta_as_secs_f64(),
        );

        println!("REVERSER OBJECT: Pos {:.1}/{:.1} totalForceN{:.0} Weight{:.2} totalAccel{:.5} deltaVel (fps) {:.5}",
        reverser_position[0].reverser_position().get::<ratio>(),
        reverser_position[1].reverser_position().get::<ratio>(),
        total_force.get::<newton>(),
        context.total_weight().get::<kilogram>(),
        acceleration.get::<meter_per_second_squared>(),
        self.plane_delta_speed_due_to_reverse_thrust.get::<foot_per_second>()
        );

        let total_dissimetry =
            self.reversers[1].current_thrust() - self.reversers[0].current_thrust();

        let dissimetry_torque = Torque::new::<kilogram_force_meter>(
            total_dissimetry.get::<newton>() * Self::DISTANCE_FROM_CG_TO_ENGINE_METER,
        );

        self.dissimetry_acceleration = if context.total_yaw_inertia_kg_m2().abs() > 0. {
            AngularAcceleration::new::<radian_per_second_squared>(
                dissimetry_torque.get::<kilogram_force_meter>() / context.total_yaw_inertia_kg_m2(),
            )
        } else {
            AngularAcceleration::default()
        };

        // println!(
        //     "DISSIMETRY THRUST:  {:.1}N TORQUE{:.1}Mkg INERTIA kgmÂ²{:.2} ACCEL r/s {:.5}",
        //     total_dissimetry.get::<newton>(),
        //     dissimetry_torque.get::<kilogram_force_meter>(),
        //     context.total_yaw_inertia_kg_m2(),
        //     self.dissimetry_acceleration
        //         .get::<radian_per_second_squared>(),
        // );
    }
}
impl SimulationElement for ReverserForce {
    fn write(&self, writer: &mut SimulatorWriter) {
        writer.write(
            &self.reverser_delta_speed_id,
            self.plane_delta_speed_due_to_reverse_thrust
                .get::<foot_per_second>(),
        );

        writer.write(
            &self.reverser_angular_accel_id,
            self.dissimetry_acceleration
                .get::<radian_per_second_squared>(),
        );
    }

    fn read(&mut self, reader: &mut SimulatorReader) {
        let engine_1_thrust: Mass = reader.read(&self.engine_1_thrust_id);
        let engine_2_thrust: Mass = reader.read(&self.engine_2_thrust_id);

        self.engines_thrust = [engine_1_thrust, engine_2_thrust];
    }
}
